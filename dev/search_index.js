var documenterSearchIndex = {"docs":
[{"location":"Chern/#TightBindingToolkit.Chern","page":"Chern Numbers","title":"TightBindingToolkit.Chern","text":"","category":"section"},{"location":"Chern/","page":"Chern Numbers","title":"Chern Numbers","text":"Modules = [TightBindingToolkit, TightBindingToolkit.Chern]\nPrivate = false\nPages   = [\"Chern.jl\"]","category":"page"},{"location":"Chern/#TightBindingToolkit.Chern.ChernNumber-Tuple{Hamiltonian, Vector{Int64}}","page":"Chern Numbers","title":"TightBindingToolkit.Chern.ChernNumber","text":"ChernNumber(Ham::Hamiltonian, subset::Vector{Int64}) --> Float64\n\nFunction to get Chern numbers given a Hamiltonian and a subset of bands\n\n\n\n\n\n","category":"method"},{"location":"Chern/#TightBindingToolkit.Chern.FieldStrength-Tuple{Tuple{Matrix{ComplexF64}, Matrix{ComplexF64}}}","page":"Chern Numbers","title":"TightBindingToolkit.Chern.FieldStrength","text":"FieldStrength(Links::Tuple{Matrix{ComplexF64}, Matrix{ComplexF64}}) --> Matrix{ComplexF64}\n\nFunction to calculate the product of the links over each plaquette on the BZ grid. This is the generalized Bery curvature for multiple degenerate bands.\n\n\n\n\n\n","category":"method"},{"location":"Chern/#TightBindingToolkit.Chern.FilledChernNumber-Tuple{Hamiltonian, Float64}","page":"Chern Numbers","title":"TightBindingToolkit.Chern.FilledChernNumber","text":"``julia FilledChernNumber(Ham::Hamiltonian, mu::Float64) --> Float64 Function to get the Chern number of bands filled upto a given chemical potentialmu`.\n\n\n\n\n\n","category":"method"},{"location":"Chern/#TightBindingToolkit.Chern.FindLinks-Tuple{Hamiltonian, Vector{Int64}}","page":"Chern Numbers","title":"TightBindingToolkit.Chern.FindLinks","text":"FindLinks(Ham::Hamiltonian, subset::Vector{Int64}) --> Tuple{Matrix{ComplexF64}, Matrix{ComplexF64}}\n\nFunction to get the linking matrices on each neighbouring point in the BZ. On a bond connecting ki and kj, the linking matrix U is defined such that U[m, n] = <v^m[ki]|v^n[kj]> where states[kj[1], kj[2]][:, m] = v^m[kj], the mth eigenstate at momentum kj.\n\n\n\n\n\n","category":"method"},{"location":"Chern/#TightBindingToolkit.Chern.PartialChernNumber-Tuple{Hamiltonian, Int64, Float64}","page":"Chern Numbers","title":"TightBindingToolkit.Chern.PartialChernNumber","text":"``julia PartialChernNumber(Ham::Hamiltonian, band::Int64, mu::Float64) --> Float64 Function to get the Chern number of a partially filled band given aHamiltonian, abandindex, and a chemical potentialmu`.\n\n\n\n\n\n","category":"method"},{"location":"Plot/#TightBindingToolkit.Model","page":"Plotting","title":"TightBindingToolkit.Model","text":"","category":"section"},{"location":"Plot/","page":"Plotting","title":"Plotting","text":"Modules = [TightBindingToolkit, TightBindingToolkit.PlotTB]\nPrivate = false\nPages   = [\"Plot.jl\"]","category":"page"},{"location":"Plot/#TightBindingToolkit.PlotTB.Plot_Band_Contour!-Tuple{Hamiltonian, BZ, Int64}","page":"Plotting","title":"TightBindingToolkit.PlotTB.Plot_Band_Contour!","text":"plot_band_contour!(Ham::Hamiltonian , bz::BZ , band_index::Int64) --> Plots.plot()\n\nFunction to draw equal energy contours of the bands in Hamiltonian, specifically for the band with the given band_index.\n\n\n\n\n\n","category":"method"},{"location":"Plot/#TightBindingToolkit.PlotTB.Plot_Band_Structure!-Union{Tuple{T}, Tuple{T, Vector{Vector{Float64}}}, Tuple{T, Vector{Vector{Float64}}, Vector{Int64}}} where T<:Union{BdGModel, Model}","page":"Plotting","title":"TightBindingToolkit.PlotTB.Plot_Band_Structure!","text":"plot_band_structure!(M<:Union{Model, BdGModel}, path::Vector{Vector{Float64}},  band_index::Vector{Int64} = collect(1:length(M.Ham.bands[begin])) ; labels::Vector{} = repeat([\"\"], length(path)), closed::Bool=true, nearest::Bool=true) --> Plots.plot()\n\nFunction to plot band structures of the Model along a path in the BZ determined by the given critical points. Can take in multiple bands into account ∈ band_index. labels are the Plot labels of the critical points.\n\n\n\n\n\n","category":"method"},{"location":"Plot/#TightBindingToolkit.PlotTB.Plot_FS!-Tuple{Hamiltonian, BZ, Vector{Float64}, Vector{Int64}}","page":"Plotting","title":"TightBindingToolkit.PlotTB.Plot_FS!","text":"plot_FS!(Ham::Hamiltonian , bz::BZ , Efermi::Vector{Float64} , band_index::Vector{Int64})--> Plots.plot()\n\nFunction to draw the fermi surface at Efermi for the given Hamiltonian on the given BZ. \n\ncmp determines the colorMap used for the contours.\ncbar determines whether to plot the colorbar or not.    \n\n\n\n\n\n","category":"method"},{"location":"Plot/#TightBindingToolkit.PlotTB.Plot_Fields!-Tuple{UnitCell}","page":"Plotting","title":"TightBindingToolkit.PlotTB.Plot_Fields!","text":"Plot_Fields!(uc::UnitCell ; OnSiteMatrices::Vector{Matrix{ComplexF64}}=SpinMats((uc.localDim - 1)//2), scale::Float64 = 1.0, range::Int64 = 1, cmp::Symbol = :thermal, field_thickness::Float64 = 1.0, field_opacity::Float64 = 0.6, use_lookup::Bool = false, site_size::Float64 = 12.0)\n\nFunction to plot the Fields of the UnitCell. ``\n\nrange determines the range of UnitCells plotted in real-space. default is ±1.\ncmp determines the colorScheme of chosen to differentiate b.w different fields.\nfield_thickness linewidth of the fields being plotted.\nfield_opacity : alpha value of the fields being plotted.\nuse_lookup : if you have implemented on-site terms using Bonds and not fields. \nOnSiteMatrices : the matrices w.r.t which the lookup table on each site will be decomposed to get a vector field on each site.\nsite_size : size of sublattice points being plotted.\n\n\n\n\n\n","category":"method"},{"location":"Plot/#TightBindingToolkit.PlotTB.Plot_UnitCell!-Tuple{UnitCell}","page":"Plotting","title":"TightBindingToolkit.PlotTB.Plot_UnitCell!","text":"Plot_UnitCell!(uc::UnitCell ; range::Int64 = 1, bond_cmp::Symbol = :matter, sub_cmp::Symbol = :rainbow, plot_conjugate::Bool=false, plot_labels::Vector{String} = unique(getproperty.(uc.bonds, :label)), plot_arrows::Bool = true, bond_opacity::Float64 = 0.6, site_size::Float64 = 16.0, bond_thickness::Tuple{Float64, Float64} = (4.0, 2.0), bond_rev::Bool=false, plot_lattice::Bool=false)\n\nFunction to plot the UnitCell. \n\nrange determines the range of UnitCells plotted in real-space. default is ±1.\nbond_cmp determines the colorScheme chosen to differentiate b.w different hopping types.\nplot_conjugate switches on whether the conjugate of the bonds in UnitCell are also plotted or not.\nsub_cmp is the choden colorScheme for the different sublattices.\nplot_labels is the vector of bond labels to be plotted.\nplot_arrows : whether to plot arrows on bonds.\nbond_opacity : alpha value of bonds being plotted.\nbond_thickness : linewidth of bonds being plotted.\nsite_size: size of sublattice points.\nplot_lattice: plot bonds on all sites or only on one unit cell.\n\n\n\n\n\n","category":"method"},{"location":"Model/#TightBindingToolkit.Model","page":"Tight Binding Model","title":"TightBindingToolkit.Model","text":"","category":"section"},{"location":"Model/","page":"Tight Binding Model","title":"Tight Binding Model","text":"Modules = [TightBindingToolkit, TightBindingToolkit.TBModel]\nPrivate = false\nPages   = [\"Model.jl\"]","category":"page"},{"location":"Model/#TightBindingToolkit.TBModel.Model","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.Model","text":"Model is a data type representing a general Tight Binding system.\n\nAttributes\n\nuc      ::  UnitCell: the Unit cell of the lattice.\nbz      ::  BZ: The discretized Brillouin Zone.\nHam     ::  Hamiltonian: the Hamiltonian at all momentum-points.\nT       ::  Float64: the temperature of the system.\nfilling ::  Float64: The filling of the system.\nmu      ::  Float64: The chemical potential of the system.\nstat    ::  Int64 : ±1 for bosons and fermions.\ngap     ::  Float64 : the energy gap of excitations at the given filling.\nGk      ::  Array{Matrix{ComplexF64}} : An array (corresponding to the grid of k-points in BZ) of Greens functions.\n\nInitialize this structure using \n\nModel(uc::UnitCell, bz::BZ, Ham::Hamiltonian ; T::Float64=1e-3, filling::Float64=-1.0, mu::Float64=0.0, stat::Int64=-1)\n\nYou can either input a filling, or a chemical potential. The corresponding μ for a given filling, or filling for a given μ is automatically calculated.\n\n\n\n\n\n","category":"type"},{"location":"Model/#TightBindingToolkit.TBModel.FindFilling","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.FindFilling","text":"FindFilling(bands::Vector{Float64}, mu::Float64, T::Float64, stat::Int64=-1) --> Float64\n\nFind filling at given T=temperature and mu=chemical potential, for a given bands.\n\n\n\n\n\n","category":"function"},{"location":"Model/#TightBindingToolkit.TBModel.FreeEnergy-Tuple{Model}","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.FreeEnergy","text":"FreeEnergy(M::Model; F0::Float64 = 0.0) --> Float64\n\nCalculate the free energy of the given Model.\n\n\n\n\n\n","category":"method"},{"location":"Model/#TightBindingToolkit.TBModel.GetCount-Tuple{Vector{Float64}, Float64, Float64, Int64}","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.GetCount","text":"GetCount(Es::Vector{Float64}, mu::Float64, T::Float64, stat::Int64) --> Matrix{Float64}\n\nFunction to return a diagonal matrix whose entries are M[i, i] = θ(-(E^i(k)-μ)) ––> 1 if the energy is below the chemical potential, otherwise 0.\n\n\n\n\n\n","category":"method"},{"location":"Model/#TightBindingToolkit.TBModel.GetFilling!-Tuple{Model}","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.GetFilling!","text":"GetFilling!(M::Model)\n\nFind filling for a given Model.\n\n\n\n\n\n","category":"method"},{"location":"Model/#TightBindingToolkit.TBModel.GetGap!-Tuple{Model}","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.GetGap!","text":"GetGap!(M::BdGModel)\n\nCalculate the BdG gap of the system.\n\n\n\n\n\n","category":"method"},{"location":"Model/#TightBindingToolkit.TBModel.GetGk!-Tuple{Model}","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.GetGk!","text":"GetGk!(M::Model)\n\nFinding the equal-time Greens functions in momentum space of a Model.\n\n\n\n\n\n","category":"method"},{"location":"Model/#TightBindingToolkit.TBModel.GetGr!-Tuple{Model}","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.GetGr!","text":"GetGr!(M::Model)\n\nFinding the equal-time Greens functions in real space of a Model.\n\n\n\n\n\n","category":"method"},{"location":"Model/#TightBindingToolkit.TBModel.GetMu!-Tuple{Model}","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.GetMu!","text":"GetMu!(M::Model; tol::Float64=0.001)\n\nFunction to get chemical potential for a given Model, within a tolerance.\n\n\n\n\n\n","category":"method"},{"location":"Model/#TightBindingToolkit.TBModel.SolveModel!-Tuple{Model}","page":"Tight Binding Model","title":"TightBindingToolkit.TBModel.SolveModel!","text":"SolveModel!(M::Model)\n\none-step function to find all the attributes in Model after it has been initialized.\n\n\n\n\n\n","category":"method"},{"location":"BZ/#TightBindingToolkit.BZ","page":"Brillouin Zone","title":"TightBindingToolkit.BZ","text":"","category":"section"},{"location":"BZ/","page":"Brillouin Zone","title":"Brillouin Zone","text":"Modules = [TightBindingToolkit, TightBindingToolkit.BZone]\nPrivate = false\nPages   = [\"BZ.jl\"]","category":"page"},{"location":"BZ/#TightBindingToolkit.BZone.BZ","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.BZ","text":"BZ is a data type representing a discretized Brillouin Zone in momentum space.\n\nAttributes\n\nbasis           :: Vector{ Vector{ Float64 } }: reciprocal lattice vectors of the Brillouin Zone.\ngridSize        :: Vector{Int64}: The number of points along each dimension of the grid.\nkInds           :: Vector{Array{Float64}}: the Monkhorst grid corresponding to k along bs.\nks   \t       :: Array{Vector{Float64}}: The grid of momentum vectors k.\nHighSymPoints   :: Dict: A dictionary containing the HIgh-Symmetry points Γ, K(2), and M(3).\nshift           :: Vector{Int64} : how shifted the grid is from its centre point at the Γ point, in units of 1/gridSize.\n\nInitialize this structure using \n\nBZ(gridSize::Int64) --> defaults to dims = 2\nBZ(gridSize::Int64, dims) --> Uniform grid in dimension = dims\nBZ(gridSize::Vector{Int64})\n\n\n\n\n\n","category":"type"},{"location":"BZ/#TightBindingToolkit.BZone.CombinedBZPath-Tuple{BZ, Vector{Vector{Float64}}}","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.CombinedBZPath","text":"CombinedBZPath(bz::BZ, points::Vector{Vector{Float64}} ; nearest::Bool = false, closed::Bool = true) --> Vector{Vector{Float64}}\n\nReturns a path in momentum-space of the discretized BZ which joins the given momentum points present in points as point[1] –> point[2] –> ... –> point[end] –> point[1]. The optional input nearest is the same as in GetQIndex, and closed determines if the path is a closed loop or not.\n\n\n\n\n\n","category":"method"},{"location":"BZ/#TightBindingToolkit.BZone.CombinedIndexPath-Tuple{BZ, Vector{Vector{Float64}}}","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.CombinedIndexPath","text":"CombinedIndexPath(bz::BZ, points::Vector{Vector{Float64}} ; nearest::Bool = false, closed::Bool = true) --> Vector{Vector{Int64}}\n\nReturns a path in index-space joins the given points present in points as point[1] –> point[2] –> ... –> point[end] –> point[1]. The optional input nearest is the same as in GetQIndex, and closed determines if the path is a closed loop or not.\n\n\n\n\n\n","category":"method"},{"location":"BZ/#TightBindingToolkit.BZone.FillBZ!-Tuple{BZ, UnitCell}","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.FillBZ!","text":"FillBZ!(bz::BZ, uc::UnitCell ; shift::Vector{Float64}=zeros(Float64, length(uc.primitives)))\n\nFills the BZ object with the relevant attributes, after it has been initialized with BZ(gridSize).\n\n\n\n\n\n","category":"method"},{"location":"BZ/#TightBindingToolkit.BZone.GetBZPath-Tuple{BZ, Vector{Float64}, Vector{Float64}}","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.GetBZPath","text":"GetBZPath(bz::BZ, start::Vector{Float64}, ending::Vector{Float64} ; nearest::Bool = false, exclusive::Bool = true) --> Vector{Vector{Float64}}\n\nReturns the actual path in momentum-space of the discretized BZ which joins the two momentums start and ending.  The optional input nearest is the same as in GetQIndex, and exclusive is the same as in GetIndexPath.\n\n\n\n\n\n","category":"method"},{"location":"BZ/#TightBindingToolkit.BZone.GetQIndex-Tuple{Vector{Float64}, BZ}","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.GetQIndex","text":"GetQIndex(Q::Vector{Float64}, bz::BZ ; nearest::Bool = false) --> Vector{Int64}\n\nReturns the index in the discretized BZ of the momentum point corresponding to the fiven momentum Q.  If the input nearest is set to true, will return the index of the momentum point on the grid closest to Q, if Q does not exist on the grid. \n\n\n\n\n\n","category":"method"},{"location":"BZ/#TightBindingToolkit.BZone.GetRLVs-Tuple{UnitCell}","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.GetRLVs","text":"GetRLVs( uc::UnitCell ) --> Vector{Vector{Float64}}\n\nReturns the reciprocal lattice vectors corresponding to the given Unit Cell.\n\n\n\n\n\n","category":"method"},{"location":"BZ/#TightBindingToolkit.BZone.Monkhorst-Tuple{Int64, Int64}","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.Monkhorst","text":"Monkhorst(ind::Int64, N::Int64) --> Float64\nMonkhorst(ind::Int64, N::Int64, shift::Int64, BC::Float64) --> Float64\n\nThe usual Monkhorst grid is defined as follows frac2i - (N+1)2N i1 N The modified Monkhorst grid takes into account the desired boundary condition BC, and an integer shift (if required, to change the starting point), and shifts the momentum grid accordingly.\n\n\n\n\n\n","category":"method"},{"location":"BZ/#TightBindingToolkit.BZone.ReduceQ-Tuple{Vector{Float64}, BZ}","page":"Brillouin Zone","title":"TightBindingToolkit.BZone.ReduceQ","text":"ReduceQ(Q::Vector{Float64}, bz::BZ) --> Vector{Float64}\n\nReduces a given momentum back to the range covered by the discretized Brillouin Zone.\n\n\n\n\n\n","category":"method"},{"location":"Params/#TightBindingToolkit.Params","page":"Parameters","title":"TightBindingToolkit.Params","text":"","category":"section"},{"location":"Params/","page":"Parameters","title":"Parameters","text":"Modules = [TightBindingToolkit, TightBindingToolkit.Parameters]\nPrivate = false\nPages = [\"Params.jl\"]","category":"page"},{"location":"Params/#TightBindingToolkit.Parameters.Param","page":"Parameters","title":"TightBindingToolkit.Parameters.Param","text":"Param{T} is a data type representing a general tight-binding parameter, which can span multiple bonds.\n\nAttributes\n\nvalue        ::  Vector{ Float64 }: the strength of the parameter (or even the full history of it if its changed).\nunitBonds    ::  Vector{ Bond{T} }: All the bonds this parameter lives on. These bonds are supposed to have \"unit\" strength, and ultimately get scaled by the value when making the UnitCell.\nlabel        ::  String: some string label to mark the parameter.  \ndist         ::  Float64: the distance of the bonds the parameter lives on.\n\nInitialize this structure using \n\nParam( value::Float64 )\nParam( value::Float64 , rank::Int64 )\n\n\n\n\n\n","category":"type"},{"location":"Params/#TightBindingToolkit.DesignUCell.AddAnisotropicBond!-Union{Tuple{T2}, Tuple{R}, Tuple{T}, Tuple{Param{T, R}, UnitCell{T2}, Int64, Int64, Vector{Int64}, Array{var\"#s10\", T} where var\"#s10\"<:Number, Float64, String}} where {T, R, T2}","page":"Parameters","title":"TightBindingToolkit.DesignUCell.AddAnisotropicBond!","text":"AddAnisotropicBond!( param::Param, uc::UnitCell , base::Int64 , target::Int64 , offset::Vector{Int64} , mat::Number , dist::Float64, label::String )\nAddAnisotropicBond!( param::Param, uc::UnitCell , base::Int64 , target::Int64 , offset::Vector{Int64} , mat::Matrix{<:Number} , dist::Float64, label::String )\n\nAdd a bond with the given attributes to param. If given mat attribute is a number, it is converted into a 1x1 matrix when entered into the bond.\n\n\n\n\n\n","category":"method"},{"location":"Params/#TightBindingToolkit.DesignUCell.AddIsotropicBonds!-Union{Tuple{T2}, Tuple{R}, Tuple{T}, Tuple{Param{T, R}, UnitCell{T2}, Float64, Array{var\"#s3\", T} where var\"#s3\"<:Number, String}} where {T, R, T2}","page":"Parameters","title":"TightBindingToolkit.DesignUCell.AddIsotropicBonds!","text":"AddIsotropicBonds!( param::Param, uc::UnitCell , dist::Float64 , mats::Number , label::String; checkOffsetRange::Int64=1 , subs::Vector{Int64}=collect(1:length(uc.basis)))\nAddIsotropicBonds!( param::Param, uc::UnitCell , dist::Float64 , mats::Matrix{<:Number} , label::String; checkOffsetRange::Int64=1 , subs::Vector{Int64}=collect(1:length(uc.basis)) )\n\nAdd a set of \"isotropic\" bonds, which are the same for each pair of sites at the given distance.  If given mat attribute is a number, it is converted into a 1x1 matrix when entered into the bond. The input checkOffsetRange must be adjusted depending on the input distance.  The optional input subs is meant for isotropic bonds when only a subset of sublattices are involved.\n\n\n\n\n\n","category":"method"},{"location":"Params/#TightBindingToolkit.DesignUCell.Lookup-Union{Tuple{Array{Param{T, R}, 1}}, Tuple{R}, Tuple{T}} where {T, R}","page":"Parameters","title":"TightBindingToolkit.DesignUCell.Lookup","text":"Lookup(params::Vector{Param{T, R}})\n\nReturns a lookup dictionary for a vector of parameters, instead of a unit cell (refer to Lookup).\n\n\n\n\n\n","category":"method"},{"location":"Params/#TightBindingToolkit.Parameters.AddSimilarBonds!-Union{Tuple{T2}, Tuple{R}, Tuple{T}, Tuple{Param{T, R}, UnitCell{T2}, Bond{T}}} where {T, R, T2}","page":"Parameters","title":"TightBindingToolkit.Parameters.AddSimilarBonds!","text":"AddSimilarBond!(param::Param{T, R}, uc::UnitCell{T2}, bond::Bond{T} ;  subs::Vector{Int64}=collect(1:length(uc.basis)), checkOffsetRange::Int64=2) where {T, R}\nAddSimilarBond!(param::Param{T, R}, uc::UnitCell{T2}, base::Int64, target::Int64, offset::Vector{Int64}, mat::Array{ComplexF64, T}, dist::Float64, label::String ;  subs::Vector{Int64}=collect(1:length(uc.basis)), checkOffsetRange::Int64=2) where {T, R}\n\nFunction to add bonds which are not completely isotropic, but are still related by translation (not by the unit cell primitives but by the underlying lattice primitives).\n\n\n\n\n\n","category":"method"},{"location":"Params/#TightBindingToolkit.Parameters.CreateUnitCell!-Union{Tuple{R}, Tuple{T}, Tuple{UnitCell{T}, Param{T, R}}, Tuple{UnitCell{T}, Param{T, R}, Int64}} where {T, R}","page":"Parameters","title":"TightBindingToolkit.Parameters.CreateUnitCell!","text":"CreateUnitCell!(uc::UnitCell, param::Param , index::Int64=length(param.value))\nCreateUnitCell!(uc::UnitCell, params::Vector{Param}, indices::Vector{Int64}=length.(getproperty.(params, :value)))\n\nAdd bonds corrsponding to a param to UnitCell, scaled with the param.value[index]. Also includes the broadcasted call.\n\n\n\n\n\n","category":"method"},{"location":"Params/#TightBindingToolkit.Parameters.GetParams-Union{Tuple{UnitCell{T}}, Tuple{T}} where T","page":"Parameters","title":"TightBindingToolkit.Parameters.GetParams","text":"GetParams(uc::UnitCell) --> Vector{Param}\n\nFor legacy purposes.  If you have a UnitCell built using the old technique of adding bonds directly, you can get a vector of Param using this function, corresponding to each unique bond type already present in UnitCell.\n\n\n\n\n\n","category":"method"},{"location":"Params/#TightBindingToolkit.Parameters.ModifyUnitCell!-Union{Tuple{R}, Tuple{T}, Tuple{UnitCell{T}, Param{T, R}}} where {T, R}","page":"Parameters","title":"TightBindingToolkit.Parameters.ModifyUnitCell!","text":"ModifyUnitCell!(uc::UnitCell, param::Param)\nModifyUnitCell!(uc::UnitCell, params::Vector{Param})\n\nModify all bonds in UnitCell corresponding to given param, taking the latest value in param.value. \n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.Lattice","page":"Lattice","title":"TightBindingToolkit.Lattice","text":"","category":"section"},{"location":"Lattice/","page":"Lattice","title":"Lattice","text":"Modules = [TightBindingToolkit, TightBindingToolkit.LatticeStruct, TightBindingToolkit.DesignLattice]\nPrivate = false\nPages   = [\"Lattice.jl\", \"DesignLattice.jl\"]","category":"page"},{"location":"Lattice/#TightBindingToolkit.LatticeStruct.Lattice","page":"Lattice","title":"TightBindingToolkit.LatticeStruct.Lattice","text":"Lattice{T} is a data type representing a general real-space lattice constructed out of a UnitCell{T}.\n\nAttributes\n\nuc          ::  UnitCell{T}: Unit Cell of the lattice.\nsize        ::  Vector{Int64}: size of the lattice in units of the UnitCell primitives.\nlength      ::  Int64: total number of sites.\nsites       ::  Dict{ Tuple{Int64, Vector{Int64}}, Int64} : a dictionary with key = (sublattice, offset), and the corresponding value being the site number on the lattice.\npositions   ::  Vector{ Vector{Float64}}: real-space positions of all the lattice sites.\nfields      ::  Vector{ Vector{Float64}}: the fields on all the lattice sites.\nBondSites   ::  Matrix{Int64}: a matrix with lattice.length rows such that BondSites[s, i] is the site number of the ith neighbour of site-s on the lattice.\nBondDists   ::  Matrix{Float64}: a matrix with lattice.length rows such that BondDists[s, i] is the distance to the ith neighbour of site-s on the lattice.\nBondLabels  ::  Matrix{String}: a matrix with lattice.length rows such that BondLabels[s, i] is the label of the bond to the ith neighbour of site-s on the lattice.\nBondMats    ::  Matrix{Array{ComplexF64, T}}: a matrix with lattice.length rows such that BondMats[s, i] is the Array{ComplexF64, T} of the bond connecting to the ith neighbour of site-s on the lattice.\n\nInitialize this structure using \n\nLattice( uc::UnitCell{T}, size::Vector{Int64} ; null_dist::Float64 = -1.0, null_label::String = \"-\")\n\nwhere null_dist and null_label are used for bonds which are not allowed due to given boundary conditions, but still tracked in the code.\n\n\n\n\n\n","category":"type"},{"location":"Lattice/#TightBindingToolkit.LatticeStruct.ApplyBCToSite-Tuple{Vector{Int64}, Vector{Int64}, Vector{ComplexF64}}","page":"Lattice","title":"TightBindingToolkit.LatticeStruct.ApplyBCToSite","text":"ApplyBCToSite(site::Vector{Int64}, L::Vector{Int64}, BC::Vector{ComplexF64}) -->  Vector{Int64}\n\nReturns the effective real-space offset of site given a lattice size L, and boundary conditions BC.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.LatticeStruct.FillBonds!-Union{Tuple{Lattice{T}}, Tuple{T}} where T","page":"Lattice","title":"TightBindingToolkit.LatticeStruct.FillBonds!","text":"FillBonds!(lattice::Lattice{T} ; null_dist::Float64 = -1.0, null_label::String = \"-\" ) where {T}\n\nFills all the bond information in the lattice using the bonds in UnitCell.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.LatticeStruct.FillLattice!-Union{Tuple{Lattice{T}}, Tuple{T}} where T","page":"Lattice","title":"TightBindingToolkit.LatticeStruct.FillLattice!","text":"FillLattice!( lattice::Lattice{T} ; null_dist::Float64 = -1.0, null_label::String = \"-\") where {T}\n\nWrapper function to fill both site and bond information in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.LatticeStruct.FillSites!-Union{Tuple{Lattice{T}}, Tuple{T}} where T","page":"Lattice","title":"TightBindingToolkit.LatticeStruct.FillSites!","text":"FillSites!(lattice::Lattice{T})\n\nFills all the sites, positions, and fields of the lattice using information in the UnitCell.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.LatticeStruct.GetBCPhase-Tuple{Vector{Int64}, Vector{Int64}, Vector{ComplexF64}}","page":"Lattice","title":"TightBindingToolkit.LatticeStruct.GetBCPhase","text":"GetBCPhase(site::Vector{Int64}, L::Vector{Int64}, BC::Vector{ComplexF64}) --> ComplexF64\n\nReturns the effective phase of site given a lattice size L, and boundary conditions BC.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.DesignLattice.CreateLattice-Union{Tuple{R}, Tuple{T}, Tuple{UnitCell{T}, Param{T, R}, Vector{Int64}}} where {T, R}","page":"Lattice","title":"TightBindingToolkit.DesignLattice.CreateLattice","text":"CreateLattice(uc::UnitCell{T}, param::Param{T}, size::Vector{Int64} , index::Int64=length(param.value) ; null_dist::Float64 = -1.0, null_label::String = \"-\") --> Lattice{T} where {T}\nCreateLattice(uc::UnitCell{T}, params::Vector{Param{T}}, size::Vector{Int64} , indices::Vector{Int64}=length.(getproperty.(params, :value)) ; null_dist::Float64 = -1.0, null_label::String = \"-\") :: Lattice{T} where {T}\n\nCreates a lattice using Param objetcs given in params.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.DesignLattice.ModifyLattice!-Union{Tuple{R}, Tuple{T}, Tuple{Lattice{T}, Param{T, R}}} where {T, R}","page":"Lattice","title":"TightBindingToolkit.DesignLattice.ModifyLattice!","text":"ModifyLattice!(lattice::Lattice{T}, param::Param{T}) where {T}\nModifyLattice!(lattice::Lattice{T}, params::Vector{Param{T}}) where {T}\n\nModifies a lattice when the Param objects given in params are modified.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.DesignLattice.RemoveLatticeBonds!-Union{Tuple{T}, Tuple{Lattice{T}, String}} where T","page":"Lattice","title":"TightBindingToolkit.DesignLattice.RemoveLatticeBonds!","text":"RemoveLatticeBonds!(lattice::Lattice{T} , label::String ; null_dist::Float64 = -1.0, null_label::String = \"-\") where {T}\n\nRemoves a lattice bond with the given label.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.DesignLattice.ScaleLattice!-Union{Tuple{R}, Tuple{T}, Tuple{Lattice{T}, Param{T, R}}} where {T, R}","page":"Lattice","title":"TightBindingToolkit.DesignLattice.ScaleLattice!","text":"ScaleLattice!(lattice::Lattice{T}, param::Param{T}) where {T}\nScaleLattice!(lattice::Lattice{T}, params::Vector{Param{T}}) where {T}\n\nScales a lattice bond assuming that the Param objects got their strengths modified.\n\n\n\n\n\n","category":"method"},{"location":"Lattice/#TightBindingToolkit.DesignLattice.ScaleLatticeBonds!-Union{Tuple{T}, Tuple{Lattice{T}, String, Float64}} where T","page":"Lattice","title":"TightBindingToolkit.DesignLattice.ScaleLatticeBonds!","text":"ScaleLatticeBonds!(lattice::Lattice{T} , label::String , scaling::Float64) where {T}\n\nScales a lattice bond with the given label and by the given scaling.\n\n\n\n\n\n","category":"method"},{"location":"conductivity/#TightBindingToolkit.conduct","page":"Electrical Conductivity","title":"TightBindingToolkit.conduct","text":"","category":"section"},{"location":"conductivity/","page":"Electrical Conductivity","title":"Electrical Conductivity","text":"Modules = [TightBindingToolkit, TightBindingToolkit.conduct]\nPrivate = false\nPages   = [\"Conductivity.jl\"]","category":"page"},{"location":"conductivity/#TightBindingToolkit.conduct.Conductivity","page":"Electrical Conductivity","title":"TightBindingToolkit.conduct.Conductivity","text":"Conductivity is a data type to track electrical conductivity of a tight-binding model.\n\nAttributes\n\nM       ::  Model: the tight-binding model whose conductivity is to be calculated.\nomegas  ::  Vector{Float64}: The range of energies to integrate over to get the DC conductivity.\nspread  ::  Float64: the disorder/spread in the real-frequency Greens function.\nspectral::  Vector{Array{Matrix{ComplexF64}}}: the matrix Spectral function at the given frequencies, and all momentum points.\nsigma   ::  Dict{String, Float64}: The dictionary containing the conductivity along the different directios.\n\nInitialize this structure using \n\nConductivity(M::Model ; spread::Float64 = 1e-3)\nConductivity(M::Model , omegas::Vector{Float64} ; spread::Float64 = 1e-3)\n\nYou can either input a filling, or a chemical potential. The corresponding μ for a given filling, or filling for a given μ is automatically calculated.\n\n\n\n\n\n","category":"type"},{"location":"conductivity/#TightBindingToolkit.conduct.GetConductivity!-Tuple{Conductivity, Vector{Int64}}","page":"Electrical Conductivity","title":"TightBindingToolkit.conduct.GetConductivity!","text":"GetConductivity!(Cond::Conductivity, as::Vector{Int64}  ; get_velocity::Bool = false, get_spectral::Bool = false)\n\nCalculates the full DC conductivity. Optional Booleans to calculate the velocity matrix of the Hamiltonian, calculate spectral functions also.\n\n\n\n\n\n","category":"method"},{"location":"conductivity/#TightBindingToolkit.conduct.SpectralContribution-Union{Tuple{N}, Tuple{Vector{Array{Matrix{ComplexF64}, N} where N}, Array{Matrix{ComplexF64}, N}, Float64}} where N","page":"Electrical Conductivity","title":"TightBindingToolkit.conduct.SpectralContribution","text":"SpectralContribution(v::Vector{Array{Matrix{ComplexF64}}}, H::Array{Matrix{ComplexF64}, N}, omega::Float64;  spread::Float64 = 1e-3, a::Int64 = 1):: ComplexF64 where {N}\nSpectralContribution(v::Vector{Array{Matrix{ComplexF64}}}, A::Array{Matrix{ComplexF64}, N};  a::Int64 = 1):: ComplexF64 where {N}\nSpectralContribution(v::Vector{Array{Matrix{ComplexF64}}}, H::Array{Matrix{ComplexF64}, N}, omega1::Float64, omega2::Float64;  spread::Float64 = 1e-3, a::Int64 = 1, b::Int64 = 2):: ComplexF64 where {N}\nSpectralContribution(v::Vector{Array{Matrix{ComplexF64}}}, A1::Array{Matrix{ComplexF64}, N}, A2::Array{Matrix{ComplexF64}, N} ;  a::Int64 = 1, b::Int64 = 2):: ComplexF64 where {N}\n\nThe contribution to the conductivity coming from the spectral function for directions a (and b). Optionally can also pass the frequencies omega (and omega2).\n\n\n\n\n\n","category":"method"},{"location":"conductivity/#TightBindingToolkit.conduct.SpectralFunction-Union{Tuple{N}, Tuple{Array{Matrix{ComplexF64}, N}, Float64}} where N","page":"Electrical Conductivity","title":"TightBindingToolkit.conduct.SpectralFunction","text":"SpectralFunction(H::Array{Matrix{ComplexF64}, N}, omega::Float64 ;  spread::Float64 = 1e-3):: Array{Matrix{ComplexF64}} where {N}\n\nReturns the matrix spectral function given the Hamiltonian, the frequency, and the spread.\n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#TightBindingToolkit.Hamiltonian","page":"Hamiltonian","title":"TightBindingToolkit.Hamiltonian","text":"","category":"section"},{"location":"Hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Modules = [TightBindingToolkit, TightBindingToolkit.Hams]\nPrivate = false\nPages   = [\"Hamiltonian.jl\"]","category":"page"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.Hamiltonian","page":"Hamiltonian","title":"TightBindingToolkit.Hams.Hamiltonian","text":"Hamiltonian is a data type representing a general momentum-space Hamiltonian corresponding to the given UnitCell and BZ (or 2 Unit Cells if it is a BdG Hamiltonian).\n\nAttributes\n\nH           :: Array{Matrix{ComplexF64}}: A Array (corresponding to the grid of k-points in BZ) of Hamiltonian matrices.\nbands       :: Array{Vector{Float64}}: A Array (corresponding to the grid of k-points in BZ) of band spectrums.\nstates      :: Array{Matrix{ComplexF64}}: A Array (corresponding to the grid of k-points in BZ) of band wavefunctions.\nbandwidth   :: Tuple{Float64, Float64} : the tuple of minimum and maximum energies in the band structure.\nis_BdG      :: Bool : is the Hamiltonian a bdG hamiltonian or a pure hopping hamiltonian.\n\nInitialize this structure using\n\nHamiltonian(uc::UnitCell, bz::BZ) --> Hopping Hamiltonian\nHamiltonian(uc_hop::UnitCell, uc_pair::UnitCell, bz::BZ) --> BdG Hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.DOS-Tuple{Float64, Vector{Float64}}","page":"Hamiltonian","title":"TightBindingToolkit.Hams.DOS","text":"DOS(Omega::Float64, Ham::Hamiltonian; till_band::Int64=length(Ham.bands[1, 1]), spread::Float64=1e-3) --> Float64\nDOS(Omegas::Vector{Float64}, Ham::Hamiltonian; till_band::Int64=length(Ham.bands[1, 1]), spread::Float64=1e-3) --> Vector{Float64}\n\nCalculate the Density of State correspondingto the given energies in Omegas, for the lowest bands upto till_band. The calculation is done at a finite spread of the delta-function sum. \n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.DiagonalizeHamiltonian!-Tuple{Hamiltonian}","page":"Hamiltonian","title":"TightBindingToolkit.Hams.DiagonalizeHamiltonian!","text":"DiagonalizeHamiltonian!(Ham::Hamiltonian)\n\nDiagonalize the Hamiltonian at all momentum points in the BZ. verbose is an optional argument to print when the Hamiltonian is diagonalized.\n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.FillHamiltonian-Tuple{UnitCell{2}, UnitCell{2}, Vector{Float64}}","page":"Hamiltonian","title":"TightBindingToolkit.Hams.FillHamiltonian","text":"FullHamiltonian(uc::UnitCell, bz::BZ) --> Matrix{Matrix{ComplexF64}}\n\nReturns the full Hamiltonian at all momentum points in BZ, corresponding to the bonds present in UnitCell.\n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.FillHoppingHamiltonian-Tuple{UnitCell{2}, Vector{Float64}}","page":"Hamiltonian","title":"TightBindingToolkit.Hams.FillHoppingHamiltonian","text":"FillHoppingHamiltonian(uc::UnitCell, k::Vector{Float64} ; OnSiteMatrices::Vector{Matrix{ComplexF64}}) --> Matrix{ComplexF64}\n\nReturns the hopping Hamiltonian at momentum point k, corresponding to the bonds present in UnitCell. OnSiteMatrices are used for the fields, with the convention that the last matrix is the one corresponding to the chemimcal potential.\n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.FillPairingHamiltonian-Tuple{UnitCell{2}, Vector{Float64}}","page":"Hamiltonian","title":"TightBindingToolkit.Hams.FillPairingHamiltonian","text":"FillPairingHamiltonian(uc::UnitCell, k::Vector{Float64}) --> Matrix{ComplexF64}\n\nReturns the pairing Hamiltonian at momentum point k, corresponding to the bonds present in UnitCell.\n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.GetVelocity!-Tuple{Hamiltonian, BZ}","page":"Hamiltonian","title":"TightBindingToolkit.Hams.GetVelocity!","text":"GetVelocity!(H::Hamiltonian, bz::BZ) --> Vector{Array{Matrix{ComplexF64}, T}}\n\nreturns a vector of velocity matrices at each k point defined as ∂H(k)/∂k^{μ}.\n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.IsBandGapped-Tuple{Hamiltonian}","page":"Hamiltonian","title":"TightBindingToolkit.Hams.IsBandGapped","text":"isBandGapped(H::Hamiltonian ; tol::Float64 = 1e-3) --> BitMatrix\n\nReturns a matrix of booleans marked as true if the band corresponding to the row and column of the matrix are gapped (greater than the tolerance), and false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#TightBindingToolkit.Hams.ModifyHamiltonianField!-Tuple{Hamiltonian, UnitCell, Vector{Float64}}","page":"Hamiltonian","title":"TightBindingToolkit.Hams.ModifyHamiltonianField!","text":"ModifyHamiltonianField!(Ham::Hamiltonian, uc::UnitCell, newFields::Vector{Float64} ; dim::Int64=4, verbose::Bool=false)\n\nFaster implementation of modifying ONLY the on-site field part of a Hamiltonian. newFields must be a vector of the same length as uc.basis. dim is an optional argument which determines which element of on-site field is being replaced.\n\n\n\n\n\n","category":"method"},{"location":"susceptibility/#TightBindingToolkit.susceptibility","page":"Magnetic susceptibility","title":"TightBindingToolkit.susceptibility","text":"","category":"section"},{"location":"susceptibility/","page":"Magnetic susceptibility","title":"Magnetic susceptibility","text":"Modules = [TightBindingToolkit, TightBindingToolkit.suscep]\nPrivate = false\nPages   = [\"Susceptibility.jl\"]","category":"page"},{"location":"susceptibility/#TightBindingToolkit.suscep.Susceptibility","page":"Magnetic susceptibility","title":"TightBindingToolkit.suscep.Susceptibility","text":"Susceptibility is a data type representing the magnetic response, χ^ab(Q  Ω) for a general tight-binding Model.\n\nAttributes\n\nM       ::  Model: the given model.\nQs      ::  Vector{Vector{Float64}}: the set of momentum points over which χ^ab(Q  Ω) is calculated.\nOmegas  ::  Vector{Float64}: the set of energies over which χ^ab(Q  Ω) is calculated.\nSpread  ::  Float64 : the finite spread when summing over delta functions.\nchis    ::  Dict: a dictionary containing χ^ab(Q  Ω) for the different directions e.g. chis[\"xx\"] etc.\n\nInitialize this structure using \n\nSusceptibility(M::Model , Omegas::Vector{Float64} ;  eta::Float64 = 1e-2) = new{}(M, [], Omegas, eta, Dict())\nSusceptibility(M::Model , Qs::Vector{Vector{Float64}}, Omegas::Vector{Float64} ;  eta::Float64 = 1e-2) = new{}(M, Qs, Omegas, eta, Dict())\n\n\n\n\n\n","category":"type"},{"location":"susceptibility/#TightBindingToolkit.suscep.FillChis!-Tuple{Susceptibility}","page":"Magnetic susceptibility","title":"TightBindingToolkit.suscep.FillChis!","text":"FillChis!(chi::Susceptibility; fill_BZ::Bool=false, a::Int64=3, b::Int64=3)\n\nfunction to calculate susceptibility at a all given Ω=Omegas, but for all Q present in the given path, and along a fixed direction given by a and b.\n\n\n\n\n\n","category":"method"},{"location":"susceptibility/#TightBindingToolkit.suscep.FindChi-Tuple{Vector{Float64}, Float64, Model}","page":"Magnetic susceptibility","title":"TightBindingToolkit.suscep.FindChi","text":"FindChi(Q::Vector{Float64}, Omega::Float64 , M::Model; a::Int64=3, b::Int64=3, eta::Float64=1e-2) --> ComplexF64\n\nfunction to calculate susceptibility at a fixed Ω=Omega, and Q, and along a fixed direction given by a and b.\n\n\n\n\n\n","category":"method"},{"location":"#TightBindingTookit.jl","page":"Introduction","title":"TightBindingTookit.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TightBindingToolkit.jl is a Julia package meant for constructing, and obtaining useful properties of generic tight-binding models. It supports any lattice structure, with any user-defined bonds on that lattice. It also has support for any spin of the particle hopping on the lattice.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently supported :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Custom Unit Cell Construction. (v1.3) : now also supports construction in dimensions upto d=3.   |(Image: Alt text)|   |Honeycomb Model with 1st, 2nd and 3rd neighbour hoppings.|\nCorresponding Brillouin Zone Construction. (v1.3) : now also supports construction in dimensions upto d=3.\nHamiltonian, given a Unit Cell and a Brillouin Zone. (v1.3) : now also support BdG Hamiltonians.\nDiagonalizing the Hamiltonian in momentum space to get band structures and wavefunctions.   |(Image: Alt text)|   |:–:|    |Band structure for a triangular lattice with 1st, 2nd and 3rd neighbour hopping.|\nDensity of State    |(Image: Alt text)|   |:–:|    |Density of state of graphene.|\nFilling the model at given chemical potential, and calculating gaps. (v1.3) : also supported for BdG systems.   |(Image: Alt text)|   |:–:|    |Band structure of the Kitaev Chain in 1-d.|\nFermi surfaces of systems   |(Image: Alt text)|   |:–:|    |Fermi surface for a triangular lattice with 1st, 2nd and 3rd neighbour hopping.|\nGetting correlation functions. (v1.3) : also supported for BdG systems.\nGetting Berry curvature and Chern numbers.   |(Image: Alt text)|   |:–:|   |Chern numbers in a spin-ful Haldane model as a function of t2.|\nGetting magnetic susceptibility in any direction, at any momentum, and energy.   |(Image: Alt text)|   |:–:|    |imaginary part of zero-energy susceptibility for a triangular lattice with 1st, 2nd and 3rd neighbour hopping.|","category":"page"},{"location":"BdGModel/#TightBindingToolkit.BdGModel","page":"BdG Model","title":"TightBindingToolkit.BdGModel","text":"","category":"section"},{"location":"BdGModel/","page":"BdG Model","title":"BdG Model","text":"Modules = [TightBindingToolkit, TightBindingToolkit.BdG]\nPrivate = false\nPages   = [\"BdGModel.jl\"]","category":"page"},{"location":"BdGModel/#TightBindingToolkit.BdG.BdGModel","page":"BdG Model","title":"TightBindingToolkit.BdG.BdGModel","text":"`BdGModel` is a data type representing a general Tight Binding system with pairing.\n\n# Attributes\n- `uc_hop  ::  UnitCell`: the Unit cell of the lattice with the hoppings.\n- `uc_pair ::  UnitCell`: the Unit cell of the lattice with the pairings.\n- `bz      ::  BZ`: The discretized Brillouin Zone.\n- `Ham     ::  Hamiltonian`: the Hamiltonian at all momentum-points.\n- `T       ::  Float64`: the temperature of the system.\n- `filling ::  Float64`: The filling of the system.\n- `mu      ::  Float64`: The chemical potential of the system.\n- `stat    ::  Int64` : ±1 for bosons and fermions.\n- `gap     ::  Float64` : the energy gap of excitations at the given filling.\n- `Gk      ::  Array{Matrix{ComplexF64}}` : An Array (corresponding to the grid of k-points in `BZ`) of Greens functions.\n- `Fk      ::  Array{Matrix{ComplexF64}}` : An Array (corresponding to the grid of k-points in `BZ`) of anomalous Greens functions.\n\nInitialize this structure using \n```julia\nBdGModel(uc_hop::UnitCell, uc_pair::UnitCell, bz::BZ, Ham::Hamiltonian ; T::Float64=1e-3, filling::Float64=-1.0, mu::Float64=0.0, stat::Int64=-1)\n```\nYou can either input a filling, or a chemical potential. The corresponding μ for a given filling, or filling for a given μ is automatically calculated.\n\n\n\n\n\n","category":"type"},{"location":"BdGModel/#TightBindingToolkit.TBModel.FindFilling-Tuple{BdGModel}","page":"BdG Model","title":"TightBindingToolkit.TBModel.FindFilling","text":"FindFilling(M::BdGModel) --> Float64\nFindFilling(mu::Float64, M::BdGModel)\n\nFind filling at given temperature and chemical potential that takes BdGModel object as argument instead of Hamiltonian, since for a BdG case, the filling depends on the wavefunctions also. Because of this, if you want to calculate the filling at a different chemical potential, you have to modify the Hamiltonian, the UnitCells, rediagonalize, and recalculate eveyrthing.\n\n\n\n\n\n","category":"method"},{"location":"BdGModel/#TightBindingToolkit.TBModel.FreeEnergy-Tuple{BdGModel}","page":"BdG Model","title":"TightBindingToolkit.TBModel.FreeEnergy","text":"FreeEnergy(M::BdGModel; F0::Float64 = 0.0) --> Float64\n\nCalculate the free energy of the given BdGModel.\n\n\n\n\n\n","category":"method"},{"location":"BdGModel/#TightBindingToolkit.TBModel.GetFilling!-Tuple{BdGModel}","page":"BdG Model","title":"TightBindingToolkit.TBModel.GetFilling!","text":"GetFilling!(M::BdGModel)\n\nFunction to get filling given a chemical potential!\n\n\n\n\n\n","category":"method"},{"location":"BdGModel/#TightBindingToolkit.TBModel.GetGap!-Tuple{BdGModel}","page":"BdG Model","title":"TightBindingToolkit.TBModel.GetGap!","text":"GetGap!(M::BdGModel)\n\nCalculate the BdG gap of the system.\n\n\n\n\n\n","category":"method"},{"location":"BdGModel/#TightBindingToolkit.TBModel.GetGk!-Tuple{BdGModel}","page":"BdG Model","title":"TightBindingToolkit.TBModel.GetGk!","text":"GetGk!(M::BdGModel)\n\nFinding the Greens functions, and anomalous greens functions in momentum space at some chemical potential.\n\n\n\n\n\n","category":"method"},{"location":"BdGModel/#TightBindingToolkit.TBModel.GetGr!-Tuple{BdGModel}","page":"BdG Model","title":"TightBindingToolkit.TBModel.GetGr!","text":"GetGr!(M::BdGModel)\n\nFinding the equal-time Greens functions and anomalous Greens function in real space of a BdGModel.\n\n\n\n\n\n","category":"method"},{"location":"BdGModel/#TightBindingToolkit.TBModel.GetMu!-Tuple{BdGModel}","page":"BdG Model","title":"TightBindingToolkit.TBModel.GetMu!","text":"GetMu!(M::BdGModel ;  tol::Float64=0.001)\n\nFunction to get the correct chemical potential given a filling.\n\n\n\n\n\n","category":"method"},{"location":"BdGModel/#TightBindingToolkit.TBModel.SolveModel!-Tuple{BdGModel}","page":"BdG Model","title":"TightBindingToolkit.TBModel.SolveModel!","text":"SolveModel!(M::BdGModel)\n\none-step function to find all the attributes in  BdGModel after it has been initialized.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.UnitCell","page":"Unit Cell","title":"TightBindingToolkit.UnitCell","text":"","category":"section"},{"location":"UnitCell/","page":"Unit Cell","title":"Unit Cell","text":"Modules = [TightBindingToolkit, TightBindingToolkit.UCell, TightBindingToolkit.DesignUCell, TightBindingToolkit.ExpandUCell]\nPrivate = false\nPages   = [\"UnitCell.jl\", \"DesignUnitCell.jl\", \"ExpandUnitCell.jl\"]","category":"page"},{"location":"UnitCell/#TightBindingToolkit.UCell.Bond","page":"Unit Cell","title":"TightBindingToolkit.UCell.Bond","text":"Bond{T} is a data type representing a general bond on a lattice.\n\nAttributes\n\nbase::Int64: sub-lattice of the initial site on the bond.\ntarget::Int64: sub-lattice of the final site on the bond.\noffset::Vector{Int64}: the difference of the unit cells in which these sublattices belong to, in units of the lattice basis vectors.\nmat::Array{ComplexF64, T}: an array describing this bond –> can be hopping for partons, or spin-exchange for spins. The rank of the array, T, is determined by the specific  model being looked at. Eg. rank = 2 for a free parton Hamiltonian.\ndist::Float64: the distance b/w the two sites = length of bond.\nlabel::String: some string label to mark the bond type.\n\n\n\n\n\n","category":"type"},{"location":"UnitCell/#TightBindingToolkit.UCell.UnitCell","page":"Unit Cell","title":"TightBindingToolkit.UCell.UnitCell","text":"UnitCell{T} is a data type representing a general unit cell of a lattice.\n\nAttributes\n\nprimitives  :: Vector{ Vector{ Float64 } }: primitive bases vectors of the lattice.\nbasis       :: Vector{ Vector{ Float64 } }: positions of the sub-lattices.\nbonds       :: Vector{Bond{T}}: the set of all bonds defining a lattice.\nfields      :: Vector{ Vector{Float64}} : the fields oneach basis site.\nlocalDim    :: Int64: Local Hilbert space dimension ( e.g. 3 for classical spins, 2 for spin-1/2 electrons ).\nBC          :: Vector{ ComplexF64 }: boundary conditions, in the form of [e^{ιθ_i}]. e.g. θ=0 for PBC, θ=π for APBC, and so on.\n\nInitialize this structure using \n\nUnitCell( as::Vector{Vector{Float64}} , localDim::Int64)\nUnitCell( as::Vector{Vector{Float64}} , localDim::Int64, rank::Int64)\n\n\n\n\n\n","category":"type"},{"location":"UnitCell/#TightBindingToolkit.UCell.AddBasisSite!-Tuple{UnitCell, Vector{Float64}}","page":"Unit Cell","title":"TightBindingToolkit.UCell.AddBasisSite!","text":"AddBasisSite!( uc::UnitCell , position::Vector{Float64} )\nAddBasisSite!( uc::UnitCell , position::Vector{Float64} , field::Vector{Float64} )\n\nAdd a sublattice to the UnitCell  at the given real-space position, with an on-site field.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.UCell.BondRank-Union{Tuple{Bond{T}}, Tuple{T}} where T","page":"Unit Cell","title":"TightBindingToolkit.UCell.BondRank","text":"BondRank(bond::Bond{T}) --> T\nBondRank(bonds::Array{Bond{T}}) --> T\n\nFunction to return rank of a bond or a collection of bonds.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.UCell.FlipBond-Union{Tuple{Bond{T}}, Tuple{T}} where T","page":"Unit Cell","title":"TightBindingToolkit.UCell.FlipBond","text":"FlipBond(bond::Bond{T}) --> Bond{T}\n\nFunction to flip a bond. Only works on bonds of rank = 2 right now.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.UCell.GetDistance-Tuple{UnitCell, Int64, Int64, Vector{Int64}}","page":"Unit Cell","title":"TightBindingToolkit.UCell.GetDistance","text":"GetDistance(uc::UnitCell, base::Int64, target::Int64, offset::Vector{Int64}) --> Float64\n\nget the distance between site at position (0, base) and (R, target), where R = offset, when written in units of the unit cell primitive vectors.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.UCell.GetRealSpacePositions-Union{Tuple{UnitCell{T}}, Tuple{T}} where T","page":"Unit Cell","title":"TightBindingToolkit.UCell.GetRealSpacePositions","text":"GetRealSpacePositions(uc::UnitCell{T} ; OffsetRange::Int64 = 2) --> Dict\n\nReturns a dictionary whose keys are vectors in the cartesian coordinates (rounded off to accuracy digits), with values giving the corresponding sublattice and Unit Cell coordinate of a lattice site at that position.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.UCell.IsSameBond-Tuple{Bond, Bond}","page":"Unit Cell","title":"TightBindingToolkit.UCell.IsSameBond","text":"IsSameBond( Bond1::Bond , Bond2::Bond ) --> Bool\n\nFunction to check if two bond objects are describing the same physical bond, just inverted! \n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.UCell.IsSameUnitCell-Tuple{UnitCell, UnitCell}","page":"Unit Cell","title":"TightBindingToolkit.UCell.IsSameUnitCell","text":"IsSameUnitCell(uc_1::UnitCell, uc_2::UnitCell) --> Bool\n\nFunction to check if two unit cell live on the same underlying lattice or not, i.e. have the same primitives, same sublattices, and same localDim.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.DesignUCell.AddAnisotropicBond!-Union{Tuple{T}, Tuple{UnitCell{T}, Int64, Int64, Vector{Int64}, Array{var\"#s10\", T} where var\"#s10\"<:Number, Float64, String}} where T","page":"Unit Cell","title":"TightBindingToolkit.DesignUCell.AddAnisotropicBond!","text":"AddAnisotropicBond!( uc::UnitCell , base::Int64 , target::Int64 , offset::Vector{Int64} , mat::Number , dist::Float64, label::String )\nAddAnisotropicBond!( uc::UnitCell , base::Int64 , target::Int64 , offset::Vector{Int64} , mat::Matrix{<:Number} , dist::Float64, label::String )\n\nAdd a bond with the given attributes to UnitCell. If given mat attribute is a number, it is converted into a 1x1 matrix when entered into the bond.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.DesignUCell.AddIsotropicBonds!-Union{Tuple{T}, Tuple{UnitCell{T}, Float64, Array{var\"#s3\", T} where var\"#s3\"<:Number, String}} where T","page":"Unit Cell","title":"TightBindingToolkit.DesignUCell.AddIsotropicBonds!","text":"AddIsotropicBonds!( uc::UnitCell{T} , dist::Float64 , mats::Number , label::String; checkOffsetRange::Int64=1 , subs::Vector{Int64}=collect(1:length(uc.basis)))\nAddIsotropicBonds!( uc::UnitCell{T} , dist::Float64 , mats::Array{<:Number, T} , label::String; checkOffsetRange::Int64=1 , subs::Vector{Int64}=collect(1:length(uc.basis)) )\n\nAdd a set of \"isotropic\" bonds, which are the same for each pair of sites at the given distance.  If given mat attribute is a number, it is converted into a 1x1 matrix when entered into the bond. The input checkOffsetRange must be adjusted depending on the input distance.  The optional input subs is meant for isotropic bonds when only a subset of sublattices are involved.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.DesignUCell.Lookup-Union{Tuple{UnitCell{T}}, Tuple{T}} where T","page":"Unit Cell","title":"TightBindingToolkit.DesignUCell.Lookup","text":"Lookup(uc::UnitCell) --> Dict\n\nReturns a dictionary with keys = (base, target, offset) for bond ∈ UnitCell bond list, and the entry being the bond matrix.  If there are multiple bonds with the same identifier, it adds them up.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.DesignUCell.ModifyBonds!-Union{Tuple{T}, Tuple{UnitCell{T}, Float64, Array{var\"#s10\", T} where var\"#s10\"<:Number}} where T","page":"Unit Cell","title":"TightBindingToolkit.DesignUCell.ModifyBonds!","text":"ModifyBonds!(uc::UnitCell, dist::Float64, newMat::Matrix{<:Number})\nModifyBonds!(uc::UnitCell, label::String, newMat::Matrix{<:Number})\n\nModify an existing bond in the UnitCell with the given label, or at a given distance=dist, to the given bond matrix.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.DesignUCell.ModifyFields!-Tuple{UnitCell, Int64, Vector{Float64}}","page":"Unit Cell","title":"TightBindingToolkit.DesignUCell.ModifyFields!","text":"ModifyFields!(uc::UnitCell, site::Int64, newField::Vector{Float64})\nModifyFields!(uc::UnitCell, newField::Vector{Vector{Float64}})\n\nModify the on-site fields in the UnitCell, either one at a time, or all of them.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.DesignUCell.ModifyIsotropicFields!-Tuple{UnitCell, Vector{Float64}}","page":"Unit Cell","title":"TightBindingToolkit.DesignUCell.ModifyIsotropicFields!","text":"ModifyIsotropicFields!(uc::UnitCell, newField::Vector{Float64})\nModifyIsotropicFields!(uc::UnitCell, newField::Float64, dim::Int64)\n\nModify the on site field uniformly, on all sublattices. The optional argument dim is if you want to only modify one of the 4 elements of on-site fields (3 Zeeman and 1 chemical potential).\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.DesignUCell.RemoveBonds!-Tuple{UnitCell, String}","page":"Unit Cell","title":"TightBindingToolkit.DesignUCell.RemoveBonds!","text":"RemoveBonds!(uc::UnitCell, dist::Float64)\nScaleBonds!(uc::UnitCell, label::String)\n\nRemove an existing bond in the UnitCell with the given label, or at a given distance=dist.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.DesignUCell.ScaleBonds!-Tuple{UnitCell, Float64, Number}","page":"Unit Cell","title":"TightBindingToolkit.DesignUCell.ScaleBonds!","text":"ScaleBonds!(uc::UnitCell, dist::Float64, scale::Number)\nScaleBonds!(uc::UnitCell, label::String, scale::Number)\n\nScale the matrix of an existing bond in the UnitCell with the given label, or at a given distance=dist, by the given scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.ExpandUCell.ChangePrimitives!-Union{Tuple{T}, Tuple{UnitCell{T}, Vector{Vector{Float64}}}} where T","page":"Unit Cell","title":"TightBindingToolkit.ExpandUCell.ChangePrimitives!","text":"ChangePrimitives!(uc::UnitCell{T}, newPrimitives::Vector{Vector{Float64}})\n\nChanges the pirmitive vectors of the given UnitCell assuming the sublattices stay the same. Changes the bonds accordingly.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.ExpandUCell.ExpandBonds!-Union{Tuple{T}, Tuple{UnitCell{T}, UnitCell{T}}} where T","page":"Unit Cell","title":"TightBindingToolkit.ExpandUCell.ExpandBonds!","text":"ExpandBonds!(ucOG::UnitCell{T}, ucNew::UnitCell{T} ; OffsetRange::Int64 = 2)\n\nAn in-place version of ExpandUnitCell which works with the new primitive vectors given in ucNew.\n\n\n\n\n\n","category":"method"},{"location":"UnitCell/#TightBindingToolkit.ExpandUCell.ExpandUnitCell-Union{Tuple{T}, Tuple{UnitCell{T}, Vector{Int64}}} where T","page":"Unit Cell","title":"TightBindingToolkit.ExpandUCell.ExpandUnitCell","text":"ExpandUnitCell(ucOG::UnitCell{T}, scaling::Vector{Int64} ; OffsetRange::Int64 = 2)\n\nReturns a UnitCell which is an integer multiple of the given UnitCell (the primitives are scaled by the given scalings along each direction). The bonds are properly redefined amongst the new sublattices and new primitive vectors.\n\n\n\n\n\n","category":"method"}]
}
